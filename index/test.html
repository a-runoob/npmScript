<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
</head>
<body>
    <input class="input" type="text" value="123" style="border: none;">
    <!-- <button class="btn">获取数据</button> -->
    <a href="weixin://">跳转到微信</a>
    <script>
        $('.input').click(()=> {
            $('.input').css('border', '1px solid #333')
        })
        $('.input').blur(() => {
            // $('input').val()
            console.log($('input').val())
            $('.input').css('border', 'none')
        })
    //    function f1(){
    //        var n=999;
    //        function f2(){
    //            console.log(n);
    //        }
    //        return f2();
    //    }
    //    f1();//  999   f2是闭包



    //     function f1(){
    //        var n=999;
    //        add=function(){
    //            n=n+1;
    //        }
    //        function f2(){
    //            console.log(n);
    //        }
    //        return f2();
    //    }
    //    f1();//999  此时已经执行了f2（）
    //    add();
    //    f1();//999   再次调用f1  add未调用


    /*
    
   function f1(){

　　　　    var n=999;
            console.log('外部:'+this)//window

　　　　nAdd=function(){n+=1}  
　　　　function f2(){
    console.log('内部:'+this)//window

　　　　　　console.log(n)
// alert(n)
　　　　}

　　　　return f2;

　　}

　　var result=f1();  //存到全局变量中  result

　　result(); // 999

　　nAdd();   //nAdd是局部变量   相当于在函数外部对函数内部局部变量进行了操作

　　result(); // 1000




　　var name = "The Window";   
　　var object = {   
　　　　name : "My Object",   
　　　　getNameFunc : function(){   
             console.log('外部:'+this)  //object
　　　　　　return function(){     //匿名函数 具有全局性  this通常是指向window的。
               console.log('内部:'+this)  //指向window
　　　　　　　　return this.name;   
　　　　　};   
　　　　}   
};   
console.log(object.getNameFunc()());  //The Window


//解决办法  调用到my Object

var name='window';
var obj={
    name:'object',
    f1:function(){
        console.log('外部'+this);
        var that=this;
        return function(){
            console.log('内部'+this);
            return that.name;
        }
    }
}
console.log(obj.f1()()); //object


var name=1;
var obj={
    name:2,
    f1:function(){
        console.log('外部'+this);
        var that=this; //第一种方法
         return function f2(name){
            console.log('内部'+this.name);
            return this.name;
        }


        // f2.apply(this,[name]);  //f2的this指向了  obj
        
    }
}
var func=obj.f1();  //此时this指向全局了  而调用 f1的是全局 this  所以f1中的this指向全局
console.log('修改后:'+func()); //object




console.log('\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'); 
    
    */
       　
//ES6  Promise

// function cook(){
//     var p=new Promise(function(resolove,reject){
//       setTimeout(function(){
//          console.log('吃饭');
//          resolove('炒饭');
//       },1000);
// })
//  return p;
// }

// //吃饭
// function eat(data){
//     console.log('开始吃饭：' + data);
//     var p = new Promise(function(resolve, reject){        //做一些异步操作
//         setTimeout(function(){
//             console.log('吃饭完毕!');
//             resolve('一块碗和一双筷子');
//         }, 2000);
//     });
//     return p;
// }
// cook().then(eat);



// 只要new了一个Promise  里面的回调函数代码就会执行
// var p=new Promise(function(resolve,reject){
//     console.log('异步操作执行');
// })
// 由于异步 无法返回return 值    所以Promise()解决了这个问题   有 resolve 和 reject来解决异步无法返回的问题
// function func(a){
//     return new Promise(function(resolve,reject){  
//         if (a>9)
//             resolve(a);
//         else reject(a-2);    

//     })
// }
// func(10).then(function(data){
//     console.log(data);
//     return parseInt(data)-2;
// })
// .then(data=>{console.log(data)})
// .catch(err=>{console.log('自己处理方式:'+err.message)}); //任意一个 then执行错误  都会直接跳到 catch  
// //promise  +   $.ajax({})
// $(function(){
//     $('.btn').click(function(){
//         $.ajax({
//             url:'./json/test.json',
//             type:'get',
//             dataType:'json',
            
//         }).then((res)=>{               //
//                 console.log(res);
//             })
//     })
// })

function func(){   //异步
    return  new Promise((resolve,reject)=>{
        setTimeout(()=>{
            console.log('异步函数已执行')
            resolve(); 
        },2000)
    })
}

async function func1(){
    console.log('异步还未执行')
    await func();   //func为异步函数  
    console.log('执行');
    return '我是最后一个执行';      //返回一个Promise对象
}
func1().then(data=>{
    console.log(data)
});



// //ES6新特性   class

// class Person{
//     static info={
//         name:'huang',
//         age:12
//     }
// }

// //直接通过类名访问静态属性
// console.log(Person.info.name); //huang

// //访问实例属性
// var per=new Person();
// console.log(per.constructor.info.name);//huang

    </script>
</body>
</html>